import numpy
import pandas
from enum import Enum
from scipy.stats import t
import matplotlib.pyplot as plt

class Event(Enum):
    EnterPieceForMachineA = 1;
    EnterPieceForMachineB =2;
    CompletionOfServiceOfMachineA=3
    CompletionOfServiceOfMachineB=4
    CompletionOfServiceOfMachineC=5
    OccurrenceOfMachineFailureA=6;
    OccurrenceOfMachineFailureB=7;
    FinishMachineRepairingA=8;
    FinishMachineRepairingB=9;

class MachineStatus(Enum):
    NotBusy=0
    Serving=1
    Repairing=2

class PieceStatus(Enum):
    InProcessingByMachineA=0;
    InProcessingByMachineB=1;
    InProcessingByMachineC=2;
    InQueueOfMachineA=3;
    InQueueOfMachineB=4;
    InQueueOfMachineC_FromMachineA=5;
    InQueueOfMachineC_FromMachineB=6;
    Exited=7;


class TypeOfService(Enum):
    ServiceForPiece1ByMachineA=1;
    ServiceForPiece2ByMachineB=2;
    ServiceForPiece1ByMachineB=3;
    ServiceByMachineC=4;

class TypeOfMachine(Enum):
    MachineTypeA=1
    MachineTypeB=2
    MachineTypeC=3

class TypeOfPieces(Enum):
    PieceType1=1
    PieceType2=2

class Queue:
    def __init__(self):
        self.MaxOfQueue = 0;
        self.ListOfpiecesInQueue=[]
        
    def SetMaxOfQueue(self,maxValue):
        self.MaxOfQueue=maxValue;

    def AppendPieceToQueue(self,piece):
        self.ListOfpiecesInQueue.append(piece);

    def InsertPieceToQueue(self,piece):
        firstIndex=0
        self.ListOfpiecesInQueue.insert(firstIndex,piece);

    def IsLongerThanMaxQueueLength(self,length):
        if(self.MaxOfQueue<length):
            return True;
        else:
            return False;

    def DetermineMaxQueueLength(self):
        length=len(self.ListOfpiecesInQueue)
        if(self.IsLongerThanMaxQueueLength(length)):
            self.SetMaxOfQueue(length);

    def isQueueEmpty(self):
        if(len(self.ListOfpiecesInQueue)==0):
            return True;
        else:
            return False;

    def popPieceFromQueue(self):
        firstIndex=0
        return self.ListOfpiecesInQueue.pop(firstIndex);

    def AppendAnotherListToThisList(self,AnotherQueue):
        for i in range(0,len(AnotherQueue.ListOfpiecesInQueue)):
            self.ListOfpiecesInQueue.append(AnotherQueue.popPieceFromQueue())




    def ResetToInitial(self):
        self.MaxOfQueue = 0;
        self.ListOfpiecesInQueue=[]



class Piece:
    ListOfComplitedServicesOnPiece=[]
    def __init__(self, type,LoginTime):
        self.type = type
        self.LoginTime=LoginTime;
        self.LogoutTime="";

    def add_LogoutTime(self, LogoutTime):
        self.LogoutTime=LogoutTime
        
    def CalculateResponseTimeForOnePiece(self):
        self.ResponseTime=self.LogoutTime-self.LoginTime


    def Append_LastComplitedServiceOnPieceToListOfComplitedServices(self,prossesType):
        ListOfComplitedServicesOnPiece.append(prossesType);

    def ChangePieceStatus(self,status):
        self.PieceStatus=status;









class Machine:
    def __init__(self, type):
        self.type = type
        self.status=MachineStatus.NotBusy
        self.NumberOfPieceStartedProssesByMachine=0;
        self.NumberOfPieceComplitedProcessbyMachine=0;
        self.UsefulAndUnusefulServiceTimeForEachMachine=0;
        self.JustUsefulServiceTimeForEachMachine=0;
        self.DurationOfFailures=0


    def ChangeMachineStatus(self,status):
        self.status=status

    def add_NumberOfPieceStartedProssesByMachine(self):
        self.NumberOfPieceStartedProssesByMachine+=1


    def add_NumberOfPieceComplitedProcessByMachine(self):
        self.NumberOfPieceComplitedProcessbyMachine+=1;

    def Set_LastTimeMachineStartToProsses(self,time):
        self.LastTimeMachineStartToProsses=time;
        
    def Set_LastPieceThatMachineStartedToProsses(self,piece):
        self.LastPieceThatMachineStartedToProsses=piece;

    def Add_UsefulAndUnusefulServiceTimeForEachMachine(self,duration):
        self.UsefulAndUnusefulServiceTimeForEachMachine+=duration;

    def Add_JustUsefulServiceTimeForEachMachine(self,duration):
        self.JustUsefulServiceTimeForEachMachine+=duration;

    def Calculate_ServiceTimeForMachineInNonSetupTime(self):
        if(self.LastTimeMachineStartToProsses<TotalSetupTime):
            return CurrentTime-TotalSetupTime;
        else:
            return CurrentTime-self.LastTimeMachineStartToProsses;

    def StartProssesOnPieceByMachine(self,piece):
        self.Set_LastPieceThatMachineStartedToProsses(piece)
        self.Set_LastTimeMachineStartToProsses(CurrentTime);


    def add_DurationOfFailures(self,duration):
        self.DurationOfFailures+=duration;

    def ResetToInitial(self):
        self.status=MachineStatus.NotBusy
        self.NumberOfPieceStartedProssesByMachine=0;
        self.NumberOfPieceComplitedProcessbyMachine=0;
        self.UsefulAndUnusefulServiceTimeForEachMachine=0;
        self.JustUsefulServiceTimeForEachMachine=0;
        self.DurationOfFailures=0





MachineA = Machine(TypeOfMachine.MachineTypeA);
MachineB = Machine(TypeOfMachine.MachineTypeB);
MachineC = Machine(TypeOfMachine.MachineTypeC);

QueueOfEnterToMachineA = Queue();
QueueOfEnterToMachineBType1 = Queue();
QueueOfEnterToMachineBType2 = Queue();
QueueOfEnterToMachineC_FromMachineA = Queue();
QueueOfEnterToMachineC_FromMachineB = Queue();


CurrentTime=0;
TotalSimulationTime=10*60;
TotalSetupTime=1*60;
FEL=[];
NowIndexOfFEL=tuple();
ListOfPieces=[];
NowNumberSimulationTime=0;
MaxOfQueueOfAllTypePieceEnterToMachineB=0;
NumberTotalSimulation=10;

ResultOfResponseTime=pandas.DataFrame(columns=['NumberSimulation','AvrageResponseTimePieceType1','AvrageResponseTimePieceType2','AvrageResponseTimeTotalPiece']);

ResultOfNumberOfPieceProducted=pandas.DataFrame(columns=['NumberSimulation','NumberOfPieceProductedType1','NumberOfPieceProductedType2']);
ResultOfTotalExplotionRate=pandas.DataFrame(columns=['NumberSimulation','TotalExplotionRateMachineA','TotalExplotionRateMachineB','TotalExplotionRateMachineC']);
ResultOfMachineFailureRate=pandas.DataFrame(columns=['NumberSimulation','MachineFailureRateMachineA','MachineFailureRateMachineB','MachineFailureRateMachineC']);

ResultOfPointEstimation=pandas.DataFrame(columns=['PieceType','Point Estimation'])
ResultOfIntervalEstimation=pandas.DataFrame(columns=['PieceType','LowerBound','UpperBound'])




#define other Functions
#Function about generate Random
def GenerateRandomTimeBetweenTwoEnterA():
    return numpy.random.normal(20,3)


def GenerateRandomTimeBetweenTwoEnterB():
    time= numpy.random.normal(16,10)
    while(time<0):
        time=numpy.random.normal(16,10)
    return time

def GenerateRandomTimeBetween_FinishRepair_OccurrenceFailure_MachineA():
    return numpy.random.normal(450,50)

def GenerateRandomTimeBetween_FinishRepair_OccurrenceFailure_MachineB():
    return numpy.random.normal(210,10)

def GenerateRandomTimeForRepairMachineA():
    return numpy.random.normal(25,4)

def GenerateRandomTimeForRepairMachineB():
    return numpy.random.normal(20,4)

def GenerateRandomTimeForServiceTimeMachineA():
    time= numpy.random.normal(15,9)
    while(time<0):
        time=numpy.random.normal(15,9)
    return time

def GenerateRandomTimeForServiceTimeMachineB():
    return numpy.random.normal(18,2)

def GenerateRandomTimeForServiceTimeMachineC():
    time= numpy.random.normal(10,4)
    while(time<0):
        time=numpy.random.normal(10,4)
    return time

def GenerateRandomTimeForServiceTime_OnMachineBForPiece1():
    return numpy.random.normal(40,9)

def DeterminingDurationOfService(service):
    if(service==TypeOfService.ServiceForPiece1ByMachineA):
        return GenerateRandomTimeForServiceTimeMachineA();
    elif(service==TypeOfService.ServiceForPiece2ByMachineB):
        return GenerateRandomTimeForServiceTimeMachineB();
    elif(service==TypeOfService.ServiceForPiece1ByMachineB):
        return GenerateRandomTimeForServiceTime_OnMachineBForPiece1();
    elif(service==TypeOfService.ServiceByMachineC):
        return GenerateRandomTimeForServiceTimeMachineC();
#!
def CalculteTimeOfCompletionService(serviceDuration):
    global CurrentTime;
    return serviceDuration+CurrentTime;

def DetermineTimeOfEnterOfNextPiece(pieceType):
    global CurrentTime;
    if(pieceType==TypeOfPieces.PieceType1):
        return GenerateRandomTimeBetweenTwoEnterA()+CurrentTime;
    elif(pieceType==TypeOfPieces.PieceType2):
        return GenerateRandomTimeBetweenTwoEnterB()+CurrentTime;

def DetermineDurationOfReaparing(machineType):
    if(machineType==TypeOfMachine.MachineTypeA):
        return GenerateRandomTimeForRepairMachineA();
    elif(machineType==TypeOfMachine.MachineTypeB):
        return GenerateRandomTimeForRepairMachineB();

def DetermineFinishOfReaparing(duration):
    global CurrentTime;
    return duration+CurrentTime;


def DetermineTimeOfNextOfOccurrenceFailureMachine(machineType):
    if(machineType==TypeOfMachine.MachineTypeA):
        return GenerateRandomTimeBetween_FinishRepair_OccurrenceFailure_MachineA()+CurrentTime;
    elif(machineType==TypeOfMachine.MachineTypeB):
        return GenerateRandomTimeBetween_FinishRepair_OccurrenceFailure_MachineB()+CurrentTime;


#Function About FEL
def DeterminingFEL():
    global NowIndexOfFEL
    SortFEL();
    FirstMemberOfFEL=0
    NowIndexOfFEL=FEL[NowNumberSimulationTime][FirstMemberOfFEL]




def MoveTimeToFEL():
    global NowIndexOfFEL
    global CurrentTime
    indexOfTime=1
    CurrentTime=NowIndexOfFEL[indexOfTime];



def SortFEL():
    indexOfTime=1
    FEL[NowNumberSimulationTime].sort(key=lambda tup: tup[indexOfTime])


def AddEventToFEL(code,Time):
    FEL[NowNumberSimulationTime].append(tuple((code,Time)));


def RemoveEventFromFEL(indexOfFEL):
    FEL[NowNumberSimulationTime].remove(FEL[NowNumberSimulationTime][indexOfFEL])

#other
def isFinishedTime():
    if(CurrentTime<=TotalSimulationTime):
        return False;
    elif(CurrentTime>TotalSimulationTime):
        return True;
    else:
        print("Error")
 
def isNowInSetupTime():
    if(CurrentTime<TotalSetupTime):
        return True;
    else:
        return False;




def isMachineNotBusy(machine):
    if(machine.status==MachineStatus.NotBusy):
        return True;
    else:
        return False;

def isMachineServing(machine):
    if(machine.status==MachineStatus.Serving):
        return True;
    else:
        return False;

def isMachineRepairing(machine):
    if(machine.status==MachineStatus.Repairing):
        return True;
    else:
        return False;


def SpecifyCodeNumber():
    global NowIndexOfFEL
    indexOfCode=0
    return NowIndexOfFEL[indexOfCode];

def HandelEnterOfNewPieceEntered(pieceType):
    return AddPieceToListOfPieces(CreateNewPieceEntered(pieceType))

def CreateNewPieceEntered(pieceType):
    global CurrentTime
    piece=Piece(pieceType,CurrentTime);
    return piece;

def AddPieceToListOfPieces(piece):
    ListOfPieces[NowNumberSimulationTime].append(piece);
    return piece;

   
def MoveQueueOfMachineAToQuereMachineB():
    global QueueOfEnterToMachineA;

    if(len(QueueOfEnterToMachineA.ListOfpiecesInQueue)!=0):
        QueueOfEnterToMachineBType1.AppendAnotherListToThisList(QueueOfEnterToMachineA);
        for pieceInQueueOfEnterToMachineA in QueueOfEnterToMachineA.ListOfpiecesInQueue:
            pieceInQueueOfEnterToMachineA.ChangePieceStatus(PieceStatus.InQueueOfMachineB);

    QueueOfEnterToMachineA.ListOfpiecesInQueue=[]


def MovePieceThatWasProssesingByMachineAToQueueB():
    piece=MachineA.LastPieceThatMachineStartedToProsses;
    QueueOfEnterToMachineBType1.AppendPieceToQueue(piece);
    piece.ChangePieceStatus(PieceStatus.InQueueOfMachineB);

def MovePieceThatWasProssesingByMachineAToMachineB():
    LastPieceThatMachineAStartedToProsses=MachineA.LastPieceThatMachineStartedToProsses;
    MachineB.StartProssesOnPieceByMachine(LastPieceThatMachineAStartedToProsses);
    LastPieceThatMachineAStartedToProsses.ChangePieceStatus(PieceStatus.InProcessingByMachineB);
    serviceDeuration=DeterminingDurationOfService(TypeOfService.ServiceForPiece1ByMachineB);
    AddEventToFEL(Event.CompletionOfServiceOfMachineB,CalculteTimeOfCompletionService(serviceDeuration));

def MovePieceThatWasProssesingByMachineBToQueueB():
    LastPieceThatMachineBStartedToProsses=MachineB.LastPieceThatMachineStartedToProsses;
    LastPieceThatMachineBStartedToProsses.ChangePieceStatus(PieceStatus.InQueueOfMachineB);
    QueueOfEnterToMachineBType2.InsertPieceToQueue(LastPieceThatMachineBStartedToProsses);


def MovePieceToQueueOfEnterToMachineC_FromMachineA():
    LastPieceThatMachineAComplitedProsses=MachineA.LastPieceThatMachineStartedToProsses;
    LastPieceThatMachineAComplitedProsses.ChangePieceStatus(PieceStatus.InQueueOfMachineC_FromMachineA)
    QueueOfEnterToMachineC_FromMachineA.AppendPieceToQueue(LastPieceThatMachineAComplitedProsses)
    LastPieceThatMachineAComplitedProsses.ChangePieceStatus(PieceStatus.InQueueOfMachineC_FromMachineA)


def MovePieceToQueueOfEnterToMachineC_FromMachineB():
    LastPieceThatMachineBComplitedProsses=MachineB.LastPieceThatMachineStartedToProsses;
    QueueOfEnterToMachineC_FromMachineB.AppendPieceToQueue(LastPieceThatMachineBComplitedProsses)
    LastPieceThatMachineBComplitedProsses.ChangePieceStatus(PieceStatus.InQueueOfMachineC_FromMachineB)



def ProssesForDetermineMaxofQueue(queue):
    queue.DetermineMaxQueueLength();
    global MaxOfQueueOfAllTypePieceEnterToMachineB;
    if(queue==QueueOfEnterToMachineBType1 or queue==QueueOfEnterToMachineBType2):
        NowLengthQueueOfAllTypePieceEnterToMachineB=(len(QueueOfEnterToMachineBType1.ListOfpiecesInQueue)+len(QueueOfEnterToMachineBType2.ListOfpiecesInQueue))
        if(MaxOfQueueOfAllTypePieceEnterToMachineB<NowLengthQueueOfAllTypePieceEnterToMachineB):
            MaxOfQueueOfAllTypePieceEnterToMachineB=NowLengthQueueOfAllTypePieceEnterToMachineB;




def FindIndexOfFELCompletionOfService(machineType):
    numberOfIndexCompletionOfService=0
    indexOfCodeOfFEL=0
    for OneFutureEvent in FEL[NowNumberSimulationTime]:
        if(machineType==TypeOfMachine.MachineTypeA):
            if(OneFutureEvent[indexOfCodeOfFEL]==Event.CompletionOfServiceOfMachineA):
                return int(numberOfIndexCompletionOfService);
        elif(machineType==TypeOfMachine.MachineTypeB):
            if(OneFutureEvent[indexOfCodeOfFEL]==Event.CompletionOfServiceOfMachineB):
                return int(numberOfIndexCompletionOfService);
        
        numberOfIndexCompletionOfService+=1


def IsThereComplitionEventForMachineInFEL(machineType):
    indexOfCodeOfFEL=0
    for OneFutureEvent in FEL[NowNumberSimulationTime]:
        if(machineType==TypeOfMachine.MachineTypeA):
            if(OneFutureEvent[indexOfCodeOfFEL]==Event.CompletionOfServiceOfMachineA):
                return True;
        elif(machineType==TypeOfMachine.MachineTypeB):
            if(OneFutureEvent[indexOfCodeOfFEL]==Event.CompletionOfServiceOfMachineB):
                return True;

    return False;


def DetermineBottlenecksQueue():
    ListOfMaxOfQueue=[QueueOfEnterToMachineA.MaxOfQueue,MaxOfQueueOfAllTypePieceEnterToMachineB,QueueOfEnterToMachineC_FromMachineA.MaxOfQueue,QueueOfEnterToMachineC_FromMachineB.MaxOfQueue];
    if(QueueOfEnterToMachineA.MaxOfQueue==max(ListOfMaxOfQueue)):
        return "Queue Of Enter To Machine A "
    elif(MaxOfQueueOfAllTypePieceEnterToMachineB==max(ListOfMaxOfQueue)):
        return "Queue Of Enter To Machine B "
    elif(QueueOfEnterToMachineC_FromMachineA.MaxOfQueue==max(ListOfMaxOfQueue)):
        return "Queue Of Enter To Machine C From Machine A"
    elif(QueueOfEnterToMachineC_FromMachineB.MaxOfQueue==max(ListOfMaxOfQueue)):
        return "Queue Of Enter To Machine C From Machine B"


def initializationOfVariables(NumberOfSimulation1):
    global CurrentTime;
    global TotalSimulationTime
    global NowNumberSimulationTime;
    global NumberOfPieceThatExitedFromSystemInNonSetupTimeType1;
    global NumberOfPieceThatExitedFromSystemInNonSetupTimeType2;
    global MaxOfQueueOfAllTypePieceEnterToMachineB;
    
    CurrentTime=0;
    TotalSimulationTime=10*60;
    NowNumberSimulationTime=NumberOfSimulation1;
    NumberOfPieceThatExitedFromSystemInNonSetupTimeType1=0;
    NumberOfPieceThatExitedFromSystemInNonSetupTimeType2=0;
    MaxOfQueueOfAllTypePieceEnterToMachineB=0;
    FEL.extend([[]]);
    AddEventToFEL(Event.EnterPieceForMachineA,GenerateRandomTimeBetweenTwoEnterA());
    AddEventToFEL(Event.EnterPieceForMachineB,GenerateRandomTimeBetweenTwoEnterB());
    AddEventToFEL(Event.OccurrenceOfMachineFailureA,GenerateRandomTimeBetween_FinishRepair_OccurrenceFailure_MachineA())
    AddEventToFEL(Event.OccurrenceOfMachineFailureB,GenerateRandomTimeBetween_FinishRepair_OccurrenceFailure_MachineB())
    ListOfPieces.extend([[]]);


    MachineA.ResetToInitial();
    MachineB.ResetToInitial();
    MachineC.ResetToInitial();

    QueueOfEnterToMachineA.ResetToInitial();
    QueueOfEnterToMachineBType1.ResetToInitial();
    QueueOfEnterToMachineBType2.ResetToInitial();
    QueueOfEnterToMachineC_FromMachineA.ResetToInitial();
    QueueOfEnterToMachineC_FromMachineB.ResetToInitial();


    


def ProssesForExitOfLastPieceThatCompliteServiceByLastMachineOfSystem():
    piece=MachineC.LastPieceThatMachineStartedToProsses;
    piece.add_LogoutTime(CurrentTime);
    piece.CalculateResponseTimeForOnePiece();
    piece.ChangePieceStatus(PieceStatus.Exited)

def add_NumberOfPieceThatExitedFromSystemInNonSetupTime(type):
    global NumberOfPieceThatExitedFromSystemInNonSetupTimeType1;
    global NumberOfPieceThatExitedFromSystemInNonSetupTimeType2;
    if(type==TypeOfPieces.PieceType1):
            NumberOfPieceThatExitedFromSystemInNonSetupTimeType1+=1;
    elif(type==TypeOfPieces.PieceType2):
            NumberOfPieceThatExitedFromSystemInNonSetupTimeType2+=1;


def Exemine_ShowResult():
    ResultOfpiecesTable = pandas.DataFrame(columns=['Type Of Piece','Status of piece','EnterTime', 'ExitTime', 'ResponseTime'])
    for OnePiece in ListOfPieces[NowNumberSimulationTime][:]:

        if(OnePiece.PieceStatus==PieceStatus.Exited):
            if(OnePiece.LogoutTime>TotalSetupTime):
                ResultOfpiecesTable = ResultOfpiecesTable.append({
                    'Type Of Piece':OnePiece.type,
                    'Status of piece':OnePiece.PieceStatus,
                    'EnterTime': OnePiece.LoginTime,
                    'ExitTime': OnePiece.LogoutTime,
                    'ResponseTime': OnePiece.ResponseTime
                    }, ignore_index=True)

        else:
            ResultOfpiecesTable = ResultOfpiecesTable.append({
                'Type Of Piece':OnePiece.type,
                'Status of piece':OnePiece.PieceStatus,
                'EnterTime': OnePiece.LoginTime,
                }, ignore_index=True)


    print('------------------------------------------------------------------')
    print("Result for each piece:")
    print('\n')
    print(ResultOfpiecesTable)

    
    ResultOfMachineTable = pandas.DataFrame(columns=['Machine Type','# of Piece Started Prosses By Machine In NonSetupTime','# of Piece Complited Prosses By Machine In NonSetupTime','Useful Exploitation rate','Total Exploitation rate', 'Machine Failure rate']);
    ResultOfMachineTable = ResultOfMachineTable.append({
                'Machine Type':"Machine A",
                '# of Piece Started Prosses By Machine In NonSetupTime':MachineA.NumberOfPieceStartedProssesByMachine,
                '# of Piece Complited Prosses By Machine In NonSetupTime': MachineA.NumberOfPieceComplitedProcessbyMachine,
                'Useful Exploitation rate': MachineA.JustUsefulServiceTimeForEachMachine/(TotalSimulationTime-TotalSetupTime),
                'Total Exploitation rate': MachineA.UsefulAndUnusefulServiceTimeForEachMachine/(TotalSimulationTime-TotalSetupTime),
                'Machine Failure rate': MachineA.DurationOfFailures/(TotalSimulationTime-TotalSetupTime)
                }, ignore_index=True)
    ResultOfMachineTable = ResultOfMachineTable.append({
                'Machine Type':"Machine B",
                '# of Piece Started Prosses By Machine In NonSetupTime':MachineB.NumberOfPieceStartedProssesByMachine,
                '# of Piece Complited Prosses By Machine In NonSetupTime': MachineB.NumberOfPieceComplitedProcessbyMachine,
                'Useful Exploitation rate': MachineB.JustUsefulServiceTimeForEachMachine/(TotalSimulationTime-TotalSetupTime),
                'Total Exploitation rate': MachineB.UsefulAndUnusefulServiceTimeForEachMachine/(TotalSimulationTime-TotalSetupTime),
                'Machine Failure rate': MachineB.DurationOfFailures/(TotalSimulationTime-TotalSetupTime)
                }, ignore_index=True)
    ResultOfMachineTable = ResultOfMachineTable.append({
                'Machine Type':"Machine C",
                '# of Piece Started Prosses By Machine In NonSetupTime':MachineC.NumberOfPieceStartedProssesByMachine,
                '# of Piece Complited Prosses By Machine In NonSetupTime': MachineC.NumberOfPieceComplitedProcessbyMachine,
                'Useful Exploitation rate': MachineC.JustUsefulServiceTimeForEachMachine/(TotalSimulationTime-TotalSetupTime),
                'Total Exploitation rate': MachineC.UsefulAndUnusefulServiceTimeForEachMachine/(TotalSimulationTime-TotalSetupTime),
                'Machine Failure rate': 0
                }, ignore_index=True)

    print('------------------------------------------------------------------')
    print("Result for each machine:")
    print('\n')
    print(ResultOfMachineTable)


    SumResponseTimePieceType1=0;
    
    SumResponseTimePieceType2=0;

    for piece in  ListOfPieces[NowNumberSimulationTime][:]:
        if(piece.LogoutTime!=""):
            if(piece.LogoutTime>TotalSetupTime):
                if(piece.type==TypeOfPieces.PieceType1):
                    SumResponseTimePieceType1+=piece.ResponseTime;
                if(piece.type==TypeOfPieces.PieceType2):
                    SumResponseTimePieceType2+=piece.ResponseTime;


    ResultOfResponseTimeTable = pandas.DataFrame(columns=['Piece Type','Number of pieces producted','Avrage of ResponseTime']);
    ResultOfResponseTimeTable = ResultOfResponseTimeTable.append({
            'Piece Type':"Piece Type 1",
            'Number of pieces producted':NumberOfPieceThatExitedFromSystemInNonSetupTimeType1,
            'Avrage of ResponseTime':(SumResponseTimePieceType1/NumberOfPieceThatExitedFromSystemInNonSetupTimeType1)
            }, ignore_index=True)
    ResultOfResponseTimeTable = ResultOfResponseTimeTable.append({
            'Piece Type':"Piece Type 2",
            'Number of pieces producted':NumberOfPieceThatExitedFromSystemInNonSetupTimeType2,
            'Avrage of ResponseTime':(SumResponseTimePieceType2/NumberOfPieceThatExitedFromSystemInNonSetupTimeType2)
            }, ignore_index=True)

    print('------------------------------------------------------------------')
    print("Result for each type of piece:")
    print('\n')
    print(ResultOfResponseTimeTable)
    



    ResultOfMaxOfQueueTable = pandas.DataFrame(columns=['Queue Type','Max of Queue']);
    ResultOfMaxOfQueueTable = ResultOfMaxOfQueueTable.append({
            'Queue Type':"Queue Of Enter To Machine A",
            'Max of Queue':QueueOfEnterToMachineA.MaxOfQueue
            }, ignore_index=True)
    ResultOfMaxOfQueueTable = ResultOfMaxOfQueueTable.append({
            'Queue Type':"Queue Of Enter To Machine B",
            'Max of Queue':MaxOfQueueOfAllTypePieceEnterToMachineB
            }, ignore_index=True)
    ResultOfMaxOfQueueTable = ResultOfMaxOfQueueTable.append({
            'Queue Type':"Queue Of Enter To Machine C From Machine A",
            'Max of Queue':QueueOfEnterToMachineC_FromMachineA.MaxOfQueue
            }, ignore_index=True)
    ResultOfMaxOfQueueTable = ResultOfMaxOfQueueTable.append({
            'Queue Type':"Queue Of Enter To Machine C From Machine B",
            'Max of Queue':QueueOfEnterToMachineC_FromMachineB.MaxOfQueue
            }, ignore_index=True)


    print('------------------------------------------------------------------')
    print("Result for max of each queue:")
    print('\n')
    print(ResultOfMaxOfQueueTable)

    print('\n')
    print("******************************************************************")
    print(DetermineBottlenecksQueue(),"is bottlenecks")
    print("******************************************************************")



def CalculatePointAndIntervalEstimationOfMean():
    global ResultOfPointEstimation;
    global ResultOfIntervalEstimation;
    MeanOfPieceType1=numpy.mean(ResultOfResponseTime['AvrageResponseTimePieceType1'])
    MeanOfPieceType2=numpy.mean(ResultOfResponseTime['AvrageResponseTimePieceType2'])
    MeanOfTotalPiece=numpy.mean(ResultOfResponseTime['AvrageResponseTimeTotalPiece'])


    StdOfPieceType1=numpy.std(ResultOfResponseTime['AvrageResponseTimePieceType1'])
    StdOfPieceType2=numpy.std(ResultOfResponseTime['AvrageResponseTimePieceType2'])
    StdOfTotalPiece=numpy.std(ResultOfResponseTime['AvrageResponseTimeTotalPiece'])
    
    T_Student=t.ppf(1-(0.05/2),NumberTotalSimulation-1);


    LowerBound_EstimationOfMeanOfPieceType1=MeanOfPieceType1-(T_Student*StdOfPieceType1)/numpy.sqrt(NumberTotalSimulation);
    UpperBound_EstimationOfMeanOfPieceType1=MeanOfPieceType1+(T_Student*StdOfPieceType1)/numpy.sqrt(NumberTotalSimulation);

    
    LowerBound_EstimationOfMeanOfPieceType2=MeanOfPieceType2-(T_Student*StdOfPieceType2)/numpy.sqrt(NumberTotalSimulation);
    UpperBound_EstimationOfMeanOfPieceType2=MeanOfPieceType2+(T_Student*StdOfPieceType2)/numpy.sqrt(NumberTotalSimulation);

    
    LowerBound_EstimationOfMeanOfTotalPiece=MeanOfTotalPiece-(T_Student*StdOfTotalPiece)/numpy.sqrt(NumberTotalSimulation);
    UpperBound_EstimationOfMeanOfTotalPiece=MeanOfTotalPiece+(T_Student*StdOfTotalPiece)/numpy.sqrt(NumberTotalSimulation);



    ResultOfPointEstimation=ResultOfPointEstimation.append({
        'PieceType':'Type1',
        'Point Estimation':MeanOfPieceType1
        }, ignore_index=True)
    ResultOfPointEstimation=ResultOfPointEstimation.append({
        'PieceType':'Type2',
        'Point Estimation':MeanOfPieceType2
        }, ignore_index=True)
    ResultOfPointEstimation=ResultOfPointEstimation.append({
        'PieceType':'Total',
        'Point Estimation':MeanOfTotalPiece
        }, ignore_index=True)





    ResultOfIntervalEstimation=ResultOfIntervalEstimation.append({
        'PieceType':'Type1',
        'LowerBound':LowerBound_EstimationOfMeanOfPieceType1,
        'UpperBound':UpperBound_EstimationOfMeanOfPieceType1
        }, ignore_index=True)

    ResultOfIntervalEstimation=ResultOfIntervalEstimation.append({
        'PieceType':'Type2',
        'LowerBound':LowerBound_EstimationOfMeanOfPieceType2,
        'UpperBound':UpperBound_EstimationOfMeanOfPieceType2
        }, ignore_index=True)

    ResultOfIntervalEstimation=ResultOfIntervalEstimation.append({
        'PieceType':'Total',
        'LowerBound':LowerBound_EstimationOfMeanOfTotalPiece,
        'UpperBound':UpperBound_EstimationOfMeanOfTotalPiece
        }, ignore_index=True)



    

def SaveResult():
    global ResultOfResponseTime
    global ResultOfNumberOfPieceProducted;
    global ResultOfTotalExplotionRate
    global ResultOfMachineFailureRate
    global NumberOfPieceThatExitedFromSystemInNonSetupTimeType1;
    global NumberOfPieceThatExitedFromSystemInNonSetupTimeType2;


    SumResponseTimePieceType1=0;
    SumResponseTimePieceType2=0;
    for piece in  ListOfPieces[NowNumberSimulationTime][:]:
        if(piece.LogoutTime!=""):
            if(piece.LogoutTime>TotalSetupTime):
                if(piece.type==TypeOfPieces.PieceType1):
                    SumResponseTimePieceType1+=piece.ResponseTime;
                if(piece.type==TypeOfPieces.PieceType2):
                    SumResponseTimePieceType2+=piece.ResponseTime;

    AvrageResponseTimePieceType1=SumResponseTimePieceType1/NumberOfPieceThatExitedFromSystemInNonSetupTimeType1;
    AvrageResponseTimePieceType2=SumResponseTimePieceType2/NumberOfPieceThatExitedFromSystemInNonSetupTimeType2;
    AvrageResponseTimeTotalPiece=(SumResponseTimePieceType1+SumResponseTimePieceType2)/(NumberOfPieceThatExitedFromSystemInNonSetupTimeType1+NumberOfPieceThatExitedFromSystemInNonSetupTimeType2)

    
    ResultOfResponseTime = ResultOfResponseTime.append({
        'NumberSimulation':NowNumberSimulationTime+1,
        'AvrageResponseTimePieceType1':AvrageResponseTimePieceType1,
        'AvrageResponseTimePieceType2':AvrageResponseTimePieceType2,
        'AvrageResponseTimeTotalPiece':AvrageResponseTimeTotalPiece
        }, ignore_index=True)

    ResultOfNumberOfPieceProducted=ResultOfNumberOfPieceProducted.append({
        'NumberSimulation':NowNumberSimulationTime+1,
        'NumberOfPieceProductedType1':NumberOfPieceThatExitedFromSystemInNonSetupTimeType1,
        'NumberOfPieceProductedType2':NumberOfPieceThatExitedFromSystemInNonSetupTimeType2
        },ignore_index=True)
    
    ResultOfTotalExplotionRate=ResultOfTotalExplotionRate.append({
        'NumberSimulation':NowNumberSimulationTime+1,
        'TotalExplotionRateMachineA':MachineA.UsefulAndUnusefulServiceTimeForEachMachine/(TotalSimulationTime-TotalSetupTime),
        'TotalExplotionRateMachineB':MachineB.UsefulAndUnusefulServiceTimeForEachMachine/(TotalSimulationTime-TotalSetupTime),
        'TotalExplotionRateMachineC':MachineC.UsefulAndUnusefulServiceTimeForEachMachine/(TotalSimulationTime-TotalSetupTime)
        },ignore_index=True)
    
    ResultOfMachineFailureRate=ResultOfMachineFailureRate.append({
        'NumberSimulation':NowNumberSimulationTime+1,
        'MachineFailureRateMachineA':MachineA.DurationOfFailures/(TotalSimulationTime-TotalSetupTime),
        'MachineFailureRateMachineB':MachineB.DurationOfFailures/(TotalSimulationTime-TotalSetupTime),
        'MachineFailureRateMachineC':MachineC.DurationOfFailures/(TotalSimulationTime-TotalSetupTime)
        },ignore_index=True)
    



def showEstimationOfMean():
    CalculatePointAndIntervalEstimationOfMean()
    print("Point Estimation Of the Whole Simulation Process")
    print('\n')
    print(ResultOfPointEstimation)
    print('\n')
    print('\n')
    print("Interval Estimation Of the Whole Simulation Process")
    print('\n')
    print(ResultOfIntervalEstimation)





def draw():
    import matplotlib.pyplot as plt
    import numpy as np

    ind = np.arange(NumberTotalSimulation) 
    width = 0.35       
    plt.bar(ind, List_NumberOfPieceThatExitedFromSystemInNonSetupTimeType1, width,color='red', label='Type1')
    plt.bar(ind + width, List_NumberOfPieceThatExitedFromSystemInNonSetupTimeType2, width,color='blue',label='Type2')

    plt.xlabel('Number of Simulation')
    plt.ylabel('Number of pieces')
    plt.title('Number of piece producted per simulation')

    plt.xticks(ind + width / 2, ('1', '2', '3', '4', '5','6','7','8','9','10'))
    plt.legend(loc='best')
    plt.show()


def drawResponseTimePlot():
    import matplotlib.pyplot as plt
    import numpy as np

    List_NumberOfPieceThatExitedFromSystemInNonSetupTimeType1=[10,15,16,18,20,10,11,12,13,14]
    List_NumberOfPieceThatExitedFromSystemInNonSetupTimeType2=[11,14,18,17,21,11,12,13,14,15]

    ind = np.arange(NumberTotalSimulation) 
    width = 0.35       
    plt.bar(ind, ResultOfNumberOfPieceProducted, width,color='red', label='Type1')
    plt.bar(ind + width, ResultOfNumberOfPieceProducted, width,color='blue',label='Type2')

    plt.xlabel('Number of Simulation')
    plt.ylabel('Number of pieces')
    plt.title('Number of piece producted per simulation')

    plt.xticks(ind + width / 2, ('1', '2', '3', '4', '5','6','7','8','9','10'))
    plt.legend(loc='best')
    plt.show()


def DrawAllPlots():
    Draw_ResultOfResponseTime();
    Draw_ResultOfTotalExplotionRate();
    Draw_ResultOfMachineFailureRate();
    Draw_ResultOfNumberOfPieceProducted();

def Draw_ResultOfResponseTime():
    ax = plt.gca()
    ResultOfResponseTime.plot(x ='NumberSimulation', y='AvrageResponseTimePieceType1', kind = 'line',ax=ax)
    ResultOfResponseTime.plot(x ='NumberSimulation', y='AvrageResponseTimePieceType2', kind = 'line',ax=ax)
    plt.legend(loc='best')
    plt.title('Avrage ResponseTime For Each Type of Piece per simulation')
    plt.show()

def Draw_ResultOfTotalExplotionRate():
    ax=plt.gca()
    ResultOfTotalExplotionRate.plot(x='NumberSimulation',y='TotalExplotionRateMachineA',kind ='line',ax=ax)
    ResultOfTotalExplotionRate.plot(x='NumberSimulation',y='TotalExplotionRateMachineB',kind ='line',ax=ax)
    ResultOfTotalExplotionRate.plot(x='NumberSimulation',y='TotalExplotionRateMachineC',kind ='line',ax=ax)
    plt.legend(loc='best')
    plt.title('Total Explotion Rate For Each Machine per simulation')
    plt.show();

def Draw_ResultOfMachineFailureRate():
    ax=plt.gca()
    ResultOfMachineFailureRate.plot(x='NumberSimulation',y='MachineFailureRateMachineA',kind ='line',ax=ax)
    ResultOfMachineFailureRate.plot(x='NumberSimulation',y='MachineFailureRateMachineB',kind ='line',ax=ax)
    ResultOfMachineFailureRate.plot(x='NumberSimulation',y='MachineFailureRateMachineC',kind ='line',ax=ax)
    plt.legend(loc='best')
    plt.title('Machine Failure Rate For Each Machine per simulation')
    plt.show();

def Draw_ResultOfNumberOfPieceProducted():
    ind = numpy.arange(NumberTotalSimulation) 
    width = 0.35       
    plt.bar(ind, ResultOfNumberOfPieceProducted.loc[:]['NumberOfPieceProductedType1'], width,color='orange', label='Type1')
    plt.bar(ind + width, ResultOfNumberOfPieceProducted.loc[:]['NumberOfPieceProductedType2'], width,color='blue',label='Type2')

    plt.xlabel('Number of Simulation')
    plt.ylabel('Number of pieces')
    plt.title('Number of piece producted per simulation')

    plt.xticks(ind + width / 2,ResultOfNumberOfPieceProducted.loc[:]['NumberSimulation'] )
    plt.legend(loc='best')
    plt.show()

#******************************#
#****define Event Functions****#
#******************************#
def event_EnterPieceForMachineA():
    piece=HandelEnterOfNewPieceEntered(TypeOfPieces.PieceType1)
    AddEventToFEL(Event.EnterPieceForMachineA,DetermineTimeOfEnterOfNextPiece(TypeOfPieces.PieceType1));

    if(isMachineNotBusy(MachineA)):
        MachineA.ChangeMachineStatus(MachineStatus.Serving);
        MachineA.StartProssesOnPieceByMachine(piece)
        piece.ChangePieceStatus(PieceStatus.InProcessingByMachineA);
        serviceDeuration=DeterminingDurationOfService(TypeOfService.ServiceForPiece1ByMachineA)
        AddEventToFEL(Event.CompletionOfServiceOfMachineA,CalculteTimeOfCompletionService(serviceDeuration));
        if(isNowInSetupTime()==False):
            MachineA.add_NumberOfPieceStartedProssesByMachine();

    elif(isMachineServing(MachineA)):
        QueueOfEnterToMachineA.AppendPieceToQueue(piece);
        piece.ChangePieceStatus(PieceStatus.InQueueOfMachineA);
        ProssesForDetermineMaxofQueue(QueueOfEnterToMachineA)
    elif(isMachineRepairing(MachineA)):
        QueueOfEnterToMachineBType1.AppendPieceToQueue(piece);
        piece.ChangePieceStatus(PieceStatus.InQueueOfMachineB);
        ProssesForDetermineMaxofQueue(QueueOfEnterToMachineBType1)
  
    RemoveEventFromFEL(0);








def event_EnterPieceForMachineB():
    piece=HandelEnterOfNewPieceEntered(TypeOfPieces.PieceType2);
    AddEventToFEL(Event.EnterPieceForMachineB,DetermineTimeOfEnterOfNextPiece(TypeOfPieces.PieceType2));
    if(isMachineNotBusy(MachineB)):
        MachineB.ChangeMachineStatus(MachineStatus.Serving);
        MachineB.StartProssesOnPieceByMachine(piece);
        piece.ChangePieceStatus(PieceStatus.InProcessingByMachineB);
        serviceDeuration=DeterminingDurationOfService(TypeOfService.ServiceForPiece2ByMachineB);
        AddEventToFEL(Event.CompletionOfServiceOfMachineB,CalculteTimeOfCompletionService(serviceDeuration));
        if(isNowInSetupTime()==False):
            MachineB.add_NumberOfPieceStartedProssesByMachine();

    else:
        QueueOfEnterToMachineBType2.AppendPieceToQueue(piece)
        piece.ChangePieceStatus(PieceStatus.InQueueOfMachineB);
        ProssesForDetermineMaxofQueue(QueueOfEnterToMachineBType2);
    RemoveEventFromFEL(0);






def event_OccurrenceOfMachineFailureA():
    MachineA.ChangeMachineStatus(MachineStatus.Repairing);
    if(IsThereComplitionEventForMachineInFEL(TypeOfMachine.MachineTypeA)):
        RemoveEventFromFEL(FindIndexOfFELCompletionOfService(TypeOfMachine.MachineTypeA));
        if(isMachineNotBusy(MachineB)):
            MachineB.ChangeMachineStatus(MachineStatus.Serving);
            MovePieceThatWasProssesingByMachineAToMachineB();
        else:
            MovePieceThatWasProssesingByMachineAToQueueB();
        MoveQueueOfMachineAToQuereMachineB();
        ProssesForDetermineMaxofQueue(QueueOfEnterToMachineBType1);

    durationOfRepairing=DetermineDurationOfReaparing(TypeOfMachine.MachineTypeA);
    MachineA.add_DurationOfFailures(durationOfRepairing);
    AddEventToFEL(Event.FinishMachineRepairingA,DetermineFinishOfReaparing(durationOfRepairing));
    if(isNowInSetupTime()==False):
        MachineA.Add_UsefulAndUnusefulServiceTimeForEachMachine(MachineA.Calculate_ServiceTimeForMachineInNonSetupTime());

    RemoveEventFromFEL(0);






def event_OccurrenceOfMachineFailureB():
    MachineB.ChangeMachineStatus(MachineStatus.Repairing);

    if(IsThereComplitionEventForMachineInFEL(TypeOfMachine.MachineTypeB)):
        RemoveEventFromFEL(FindIndexOfFELCompletionOfService(TypeOfMachine.MachineTypeB));

    durationOfRepairing=DetermineDurationOfReaparing(TypeOfMachine.MachineTypeB);
    MachineB.add_DurationOfFailures(durationOfRepairing);
    AddEventToFEL(Event.FinishMachineRepairingB,DetermineFinishOfReaparing(durationOfRepairing));

    if(isNowInSetupTime()==False):
        MachineB.Add_UsefulAndUnusefulServiceTimeForEachMachine(MachineB.Calculate_ServiceTimeForMachineInNonSetupTime());
    MovePieceThatWasProssesingByMachineBToQueueB();
    ProssesForDetermineMaxofQueue(QueueOfEnterToMachineBType2);
    
    RemoveEventFromFEL(0);







def event_FinishMachineRepairingA():
    MachineA.ChangeMachineStatus(MachineStatus.NotBusy);
    AddEventToFEL(Event.OccurrenceOfMachineFailureA,DetermineTimeOfNextOfOccurrenceFailureMachine(TypeOfMachine.MachineTypeA));
    RemoveEventFromFEL(0);






def event_FinishMachineRepairingB():
    MachineB.ChangeMachineStatus(MachineStatus.NotBusy);
    AddEventToFEL(Event.OccurrenceOfMachineFailureB,DetermineTimeOfNextOfOccurrenceFailureMachine(TypeOfMachine.MachineTypeB));
    RemoveEventFromFEL(0);






def event_CompletionOfServiceOfMachineA(): 
    if(isNowInSetupTime()==False):
        MachineA.add_NumberOfPieceComplitedProcessByMachine();
        MachineA.Add_JustUsefulServiceTimeForEachMachine(MachineA.Calculate_ServiceTimeForMachineInNonSetupTime())
        MachineA.Add_UsefulAndUnusefulServiceTimeForEachMachine(MachineA.Calculate_ServiceTimeForMachineInNonSetupTime())

    if(isMachineNotBusy(MachineC)):
        MachineC.ChangeMachineStatus(MachineStatus.Serving);
        piece1=MachineA.LastPieceThatMachineStartedToProsses;
        MachineC.StartProssesOnPieceByMachine(piece1);
        piece1.ChangePieceStatus(PieceStatus.InProcessingByMachineC)
        serviceDeuration=DeterminingDurationOfService(TypeOfService.ServiceByMachineC);
        AddEventToFEL(Event.CompletionOfServiceOfMachineC,CalculteTimeOfCompletionService(serviceDeuration));
        if(isNowInSetupTime()==False):
            MachineC.add_NumberOfPieceStartedProssesByMachine();
    else:
        MovePieceToQueueOfEnterToMachineC_FromMachineA();
        ProssesForDetermineMaxofQueue(QueueOfEnterToMachineC_FromMachineA);


    if(QueueOfEnterToMachineA.isQueueEmpty()==False):
        piece2=QueueOfEnterToMachineA.popPieceFromQueue();
        MachineA.StartProssesOnPieceByMachine(piece2)
        piece2.ChangePieceStatus(PieceStatus.InProcessingByMachineA)
        serviceDeuration=DeterminingDurationOfService(TypeOfService.ServiceForPiece1ByMachineA);
        AddEventToFEL(Event.CompletionOfServiceOfMachineA,CalculteTimeOfCompletionService(serviceDeuration));
        if(isNowInSetupTime()==False):
            MachineA.add_NumberOfPieceStartedProssesByMachine();

    else:
        MachineA.ChangeMachineStatus(MachineStatus.NotBusy)
    RemoveEventFromFEL(0);









def event_CompletionOfServiceOfMachineB():
    if(isNowInSetupTime()==False):
        MachineB.add_NumberOfPieceComplitedProcessByMachine();
        MachineB.Add_JustUsefulServiceTimeForEachMachine(MachineB.Calculate_ServiceTimeForMachineInNonSetupTime())
        MachineB.Add_UsefulAndUnusefulServiceTimeForEachMachine(MachineB.Calculate_ServiceTimeForMachineInNonSetupTime())

    if(isMachineNotBusy(MachineC)):
        MachineC.ChangeMachineStatus(MachineStatus.Serving);
        piece1=MachineB.LastPieceThatMachineStartedToProsses;
        piece1.ChangePieceStatus(PieceStatus.InProcessingByMachineC)
        MachineC.StartProssesOnPieceByMachine(piece1);
        serviceDeuration=DeterminingDurationOfService(TypeOfService.ServiceByMachineC);
        AddEventToFEL(Event.CompletionOfServiceOfMachineC,CalculteTimeOfCompletionService(serviceDeuration));
        if(isNowInSetupTime()==False):
            MachineC.add_NumberOfPieceStartedProssesByMachine();
    else:
        MovePieceToQueueOfEnterToMachineC_FromMachineB();
        ProssesForDetermineMaxofQueue(QueueOfEnterToMachineC_FromMachineB);

    if(QueueOfEnterToMachineBType1.isQueueEmpty()==False):
        piece2=QueueOfEnterToMachineBType1.popPieceFromQueue();
        MachineB.StartProssesOnPieceByMachine(piece2)
        piece2.ChangePieceStatus(PieceStatus.InProcessingByMachineB)
        serviceDeuration=DeterminingDurationOfService(TypeOfService.ServiceForPiece1ByMachineB);
        AddEventToFEL(Event.CompletionOfServiceOfMachineB,CalculteTimeOfCompletionService(serviceDeuration));
        if(isNowInSetupTime()==False):
            MachineB.add_NumberOfPieceStartedProssesByMachine();

    elif(QueueOfEnterToMachineBType2.isQueueEmpty()==False):
        piece2=QueueOfEnterToMachineBType2.popPieceFromQueue();
        MachineB.StartProssesOnPieceByMachine(piece2)
        piece2.ChangePieceStatus(PieceStatus.InProcessingByMachineB)
        serviceDeuration=DeterminingDurationOfService(TypeOfService.ServiceForPiece1ByMachineB);
        AddEventToFEL(Event.CompletionOfServiceOfMachineB,CalculteTimeOfCompletionService(serviceDeuration));
        if(isNowInSetupTime()==False):
            MachineB.add_NumberOfPieceStartedProssesByMachine();

    else:
        MachineB.ChangeMachineStatus(MachineStatus.NotBusy)
    RemoveEventFromFEL(0);







def event_CompletionOfServiceOfMachineC():
    ProssesForExitOfLastPieceThatCompliteServiceByLastMachineOfSystem();
    if(isNowInSetupTime()==False):
        MachineC.add_NumberOfPieceComplitedProcessByMachine();
        MachineC.Add_JustUsefulServiceTimeForEachMachine(MachineC.Calculate_ServiceTimeForMachineInNonSetupTime())
        MachineC.Add_UsefulAndUnusefulServiceTimeForEachMachine(MachineC.Calculate_ServiceTimeForMachineInNonSetupTime())
        add_NumberOfPieceThatExitedFromSystemInNonSetupTime(MachineC.LastPieceThatMachineStartedToProsses.type);



    if(QueueOfEnterToMachineC_FromMachineA.isQueueEmpty()==False):
        piece=QueueOfEnterToMachineC_FromMachineA.popPieceFromQueue();
        MachineC.StartProssesOnPieceByMachine(piece)
        piece.ChangePieceStatus(PieceStatus.InProcessingByMachineC)
        serviceDeuration=DeterminingDurationOfService(TypeOfService.ServiceByMachineC);
        AddEventToFEL(Event.CompletionOfServiceOfMachineC,CalculteTimeOfCompletionService(serviceDeuration));
        if(isNowInSetupTime()==False):
            MachineC.add_NumberOfPieceStartedProssesByMachine();

    elif(QueueOfEnterToMachineC_FromMachineB.isQueueEmpty()==False):
        piece=QueueOfEnterToMachineC_FromMachineB.popPieceFromQueue();
        MachineC.StartProssesOnPieceByMachine(piece)
        piece.ChangePieceStatus(PieceStatus.InProcessingByMachineC)
        serviceDeuration=DeterminingDurationOfService(TypeOfService.ServiceByMachineC);
        AddEventToFEL(Event.CompletionOfServiceOfMachineC,CalculteTimeOfCompletionService(serviceDeuration));
        if(isNowInSetupTime()==False):
            MachineC.add_NumberOfPieceStartedProssesByMachine();
    
    else:
        MachineC.ChangeMachineStatus(MachineStatus.NotBusy)
    RemoveEventFromFEL(0);


#Function about Events
def TransitionToEvent(code):
    if(code==Event.EnterPieceForMachineA):
        event_EnterPieceForMachineA();
    elif(code==Event.EnterPieceForMachineB):
        event_EnterPieceForMachineB();
    elif(code==Event.CompletionOfServiceOfMachineA):
        event_CompletionOfServiceOfMachineA();
    elif(code==Event.CompletionOfServiceOfMachineB):
        event_CompletionOfServiceOfMachineB();
    elif(code==Event.CompletionOfServiceOfMachineC):
        event_CompletionOfServiceOfMachineC();
    elif(code==Event.OccurrenceOfMachineFailureA):
        event_OccurrenceOfMachineFailureA();
    elif(code==Event.OccurrenceOfMachineFailureB):
        event_OccurrenceOfMachineFailureB();
    elif(code==Event.FinishMachineRepairingA):
        event_FinishMachineRepairingA();
    elif(code==Event.FinishMachineRepairingB):
        event_FinishMachineRepairingB();
    else:
        print("Error")




#Controler
for NumberOfSimulation in range(0,10):
    initializationOfVariables(NumberOfSimulation);
    while(isFinishedTime()==False):
        DeterminingFEL();
        MoveTimeToFEL();
        TransitionToEvent(SpecifyCodeNumber())

    #show result
    print("Result of",NumberOfSimulation+1,"th Simulation:")
    print("___________________________")
    Exemine_ShowResult()
    SaveResult()
    print("\n\n\n\n\n\n\n\n\n\n\n\n");


showEstimationOfMean()
DrawAllPlots()